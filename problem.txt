Unfortunately it seems the new global pipe using mg_wakeup() and struct mg_str leaves a serious memory-leak loophole.

mg_wakeup() may return true signalling to a separate POSIX thread that the message corresponding to a given session->conn_id has been passed over to the mongoose event loop successfully. However, in the meantime a user might have closed the matching WebSocket connection (the one with c->conn_id).

This would mean that the mg_str actually pointing to another C structure web socket_message, with its malloced payload, would not be delivered to the MG_EV_WAKEUP event handler, where the payload memory would be expected to be released.

The mongoose code is not aware of the fact that mg_str->ptr now points to another structure, with its associated memory buffer.

To make matters worse, in the mg_wakeup() function the send command send(mgr->pipe, extended_buf, len + sizeof(conn_id), MSG_NONBLOCKING); loses a direct link to conn_id, it cannot tell whether or not the

const void *buf,
size_t len
buffer has actually been delivered all the way to the conn_id MG_EV_WAKEUP handler.

This scenario is not hypothetical, it is actually very likely to happen when separate non-mongoose threads (like in my code) call mg_wakeup() with non-string payloads (complex binary structures).

The previous point-to-point approach with mg_mkpipe() and mg_queue did not suffer from this problem. There were fewer intermediate steps. Either my payload was inserted successfully into the mg_queue or not. Two very clear outcomes. Either way my binary payload would be released without any memory leaks. The new global mg_wakeup() breaks this clear chain of command.

I think it might be worth to re-think the new mg_wakeup() functionality, re-design it so that it gives a clear feedback as to whether or not the payloads have been delivered all the way until the final MG_EV_WAKEUP event handler destination corresponding to c->conn_id. Failures should be communicated all the way back to the original caller of the mg_wakeup() function. Right now it's not happening.

I sincerely hope you can understand what I have been trying to say!

==========
[C] calling fetch_realtime_image_spectrum across the cluster for 'ALMA01575449'
[C] aborting fetch_realtime_image_spectrum (no cluster nodes found)
[C] x265_encode::ret = 1, #frames = 1
[C] video_response elapsed: 0.821060 [ms], msg_len: 1036 bytes.
[WS] {"quality":"high","ref_freq":115271000000,"height":178,"frame_end":1.15554681264e11,"dx":800,"intensity":"mean","image":false,"x2":276,"beam":"square","width":178,"x1":511,"y1":245,"frame_start":1.1460395996665518e11,"y2":879,"timestamp":73461,"type":"realtime_image_spectrum","seq_id":1921}
[WS] {"quality":"high","ref_freq":88662530000,"height":194,"frame_end":8.86921046366e10,"dx":800,"intensity":"mean","image":false,"x2":157,"beam":"square","width":194,"x1":59,"y1":212,"frame_start":8.863913646245232e10,"y2":49,"timestamp":73461,"type":"realtime_image_spectrum","seq_id":1921}
[WS] {"quality":"high","ref_freq":230538000000,"height":62,"frame_end":2.30630279039e11,"dx":800,"intensity":"integrated","image":false,"x2":308,"beam":"circle","width":62,"x1":46,"y1":79,"frame_start":2.3044615159601025e11,"y2":779,"timestamp":73461,"type":"realtime_image_spectrum","seq_id":1922}
[WS] {"quality":"low","ref_freq":93173402000,"height":197,"frame_end":9.31811718254e10,"dx":800,"intensity":"mean","image":false,"x2":343,"beam":"circle","width":197,"x1":1374,"y1":897,"frame_start":9.317185856709592e10,"y2":241,"timestamp":69637,"type":"realtime_image_spectrum","seq_id":1920}
[C] ws_event_loop::wakeup.
[C] ws_event_loop::got a request id 1922.
[WS] {"quality":"medium","ref_freq":322800000000,"height":56,"frame_end":3.232823969470402e11,"dx":800,"intensity":"mean","image":false,"x2":243,"beam":"square","width":56,"x1":509,"y1":558,"frame_start":3.214121472414e11,"y2":320,"timestamp":73461,"type":"realtime_image_spectrum","seq_id":1921}
[C] ws_event_loop::wakeup.
[C] ws_event_loop::wakeup.
[C] ws_event_loop::got a request id 1921.
[C] ws_event_loop::wakeup.
[C] pthread_join rc = 0
[C] spectrum compressed size: 880 bytes
[C] float array size: 1600, compressed: 880 bytes
[C] viewport pixels compressed size: 2224 bytes
[C] viewport mask raw size: 4374; compressed: 62 bytes
[C] ws_event_loop::got a request id 1906.
[C] PIPE_END_OF_STREAM
[C] spectrum length: 400, elapsed: 23.534533 [ms], compressed_size: 880, msg_len: 900 bytes.
[C] viewport elapsed: 23.534533 [ms], processing 9x486 viewport, msg_len = 2318
[C] pthread_create rc = 0
[C] pthread_create rc = 0
[WS] {"quality":"low","ref_freq":240335000000,"height":133,"frame_end":2.404491112053851e11,"dx":800,"intensity":"mean","image":false,"x2":245,"beam":"circle","width":133,"x1":89,"y1":452,"frame_start":2.40214879435e11,"y2":377,"timestamp":73461,"type":"realtime_image_spectrum","seq_id":1922}
[C] pthread_create rc = 0
[C] calling fetch_realtime_image_spectrum across the cluster for 'ALMA01575449'
[C] aborting fetch_realtime_image_spectrum (no cluster nodes found)
[C] calling fetch_realtime_image_spectrum across the cluster for 'ALMA01015786'
[C] aborting fetch_realtime_image_spectrum (no cluster nodes found)
[C] calling fetch_realtime_image_spectrum across the cluster for 'ALMA01047077'
[C] aborting fetch_realtime_image_spectrum (no cluster nodes found)
[C] ws_event_loop::wakeup.
[C] pthread_join rc = 0
[C] spectrum compressed size: 32 bytes
[C] float array size: 1600, compressed: 32 bytes
[C] PIPE_END_OF_STREAM
[C] spectrum length: 400, elapsed: 2.103163 [ms], compressed_size: 32, msg_len: 52 bytes.

^C^C


